# Redis




## 数据类型

String

底层实现：SDS，相比于c语言中的string有以下优点

1. 可以保存除文本外的音视频图片信息。底层以二进制形式的数据保存至buf[]中，因此可以存音视频图片等二进制文件信息
2. 查询字符串长度的时间复杂度为O(1)。因为底层记录了字符串的长度大小
3. 高效拼接字符串，且之前会检查容量是否足够，避免缓冲区溢出

应用场景

1. 存Json格式的对象信息
2. 计数器
   当key为整数时，提供了相关的api能对整数进行简单的增值降值操作。可以实现点赞/转发/访问数量等
3. 分布式锁
   set 命令有个参数 NX 可以实现key值不存在时成功插入，存在时插入失败。可对应key存在时，对应加锁失败，不存在时对应加锁成功。
   对于解锁的过程，有两个步骤：判断锁的unique_value是否为加锁的客户端、删除lock_key锁。这时就需要lua脚本保证解锁的原子性。
4. 共享session
   当有多个服务器时，同一个用户可能每次访问不同的服务器，因而每次获取到的session不一致。可以通过在redis中统一存储sessionId，每个服务器都与redis建立连接，每个服务器都只会去同一个redis中获取session信息



List

底层实现：老版本是双向链表或压缩链表，redis 3.2 之后则统一由quicklist实现

应用场景：

1. 消息队列
   消息有序性：lpush+brpop实现（rpush+blpop也可）。使用brpop不使用rpop的原因是，brpop为阻塞式取数据，如果列表中没有数据时会阻塞等待直到有数据过来。如果用rpop，就需要消费者死循环不断去列表中获取，这很消耗cpu资源。

   处理重复消息：给消息附加上一个全局唯一id标识，消费者消费之前判断是否消息过这条消息

   可靠性：BRPOPLPUSH，消费者从list读取消息时，同时会将该消息写道另外一个list（备份list）。这样即使消费者在处理消息时宕机了，重启可以从备份list获取消息重新处理

​		不过上述方式实现的消息队列，每条消息只能被一个消费者消费

Hash

底层实现：老版本是压缩链表或哈希表，redis 7.0之后统一由listpack实现

应用场景：

1. 购物车
   用户id + 商品id:购买数量，刚好构成了购物车的三要素。
   以用户id为key，商品id:购买数量键值对为value，存入hash中即可

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/redis/%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/%E8%B4%AD%E7%89%A9%E8%BD%A6.png)



Set

有序的、元素不可重复的集合

底层实现：整数集合或哈希表

应用场景：

1. 点赞
   与点赞相关的业务：数量、只能点赞一次、获取点赞的用户

2. 共同关注
   交集。另外利用差集，可以给对方推荐自己关注的公众号
3. 抽奖活动
   使用srandmember实现可重复中奖
   使用spop实现不可重复中奖



ZSet

有序的、元素不可重复的集合

底层实现：老版本压缩列表或跳表实现，redis 7.0之后由listpack实现

应用场景：

1. 排行榜

2. 电话、姓名排序

   ZRANGEBYLEX和 ZREVRANGEBYLEX实现，分数必须相同，设置为0即可。



Geo

底层实现：就是Zsort，只是将经纬度信息进行编码实现了到权重分数的转换

应用场景：

滴滴叫车

搜索附件车辆



BitMap

底层实现：底层是用string类型实现的数据结构，string类型会将数据最终保存为二进制字节数组buf[],所以可以把每个bit位利用起来就可以当成一个bitmap

应用场景

1. 用户签到：月签到天数（一个用户一个bitmap）、七天连续签到（一天一个bitmap，多个bitmap进行&操作）
2. 判断用户登录状态

## 持久化

### AOF日志

通过在客户端在redis中执行**写命令**之后，会将写命令追加到AOF日志文件，这样一来AOF日志文件保存了所有的写命令。系统异常造成数据丢失时，可通过执行AOF日志中的命令完成数据恢复。



Q：为什么要在执行写命令之后再写入AOF？

A：执行命令时会检查语法问题，避免写入时还要检查语法是否正确



**三种写回策略**

每执行一条写命令不会立即写入磁盘中的AOF文件，而是先写入缓冲区。后续由操作系统将缓冲区的内容追加到AOF文件。具体写回的策略有以下三种

1. Always：每执行一个命令，os就将该命令追加到AOF
2. EverySec： 每隔1s，将缓冲区的内容追加到AOF
3. No： 完全交由os决定什么时候写入AOF

可靠性：Always

高性能：No

运行数据丢一点，又想性能高：No



**AOF重写机制**

当AOF文件很大达到一定阈值时，会触发重写机制。重写机制就是读取当前redis数据库中所有的键值对，每个键值对形成一条写命令，写入新的AOF文件中，最后更名替换旧的AOF文件。



**AOF后台重写**

为避免AOF重写在主线程运行造成阻塞，采用**子进程**完成AOF的重写。

Q：为什么不是子线程而是子进程？

A：多线程之间会共享数据，在修改共享内存数据时需要通过加锁保证数据的安全，这样就会降低性能。而使用子进程，父子进程是共享内存数据的，不过这个子进程只能以**只读**的方式。当父子进程任意一方修改了共享内存，就会发送**写时复制**，于是父子进程都有了独立的数据副本，就不用加锁来保证数据安全。



  如果在子进程进行AOF重写的同时，主进程又修改了key-value，那么会导致两个问题，一个是子进程的数据跟主进程数据不一致；另一个是若是个bigkey，会造成主进程阻塞。为了解决这个问题，redis在**重写期间**，在执行一条写命令之后，会将其写入到**AOF缓冲区**和**AOF重写缓冲区**

  子进程完成重写操作后，会向父进程发送信号，父进程接收到信号后，会执行信号处理函数，这个函数执行将AOF重写缓冲区的内容追加到新的AOF文件中，新的AOF文件更名覆盖旧的AOF文件，完成AOF后台重写。



**AOF做持久化的缺点**

因为redis执行命令由单线程执行，如果AOF文件很大，这个恢复的过程就会很慢

### RDB快照

  以二进制文件的形式存储redis数据库某一时刻的数据快照。使用save和bgsave两个命令生成RDB文件，其中后者是创建子进程执行。每次在服务器启动时自动执行，也可以修改配置文件修改执行频次。该方式执行效率高于AOF日志。

  如果生成RDB快照时，数据被修改的话是无法更新至RDB快照中的，但是可以通过缓冲区追加到AOF日志文件中。

  RDB执行频率低会导致数据丢失多，频率高导致写入磁盘和创建子进程带来额外的开销。开启混合持久化功能（发送在AOF日志重写过程），`aof-use-rdb-preamble yes` ，在重写日志时，会以RBD方式写入到AOF文件中，再将重写缓冲区的**增量命令**追加到AOF文件中。写入完成后，会通知主线程新的还要RDB和AOF格式的AOF文件替换旧的AOF文件。

  如此前半部分是RDB格式的全量数据，后半部分是AOF格式的增量数据，使得数据更少丢失。

  

### 大key对持久化的影响

对于AOF日志持久化：

  只会影响Alawyas写回策略，因为每执行一个写命令就向AOF日志（立刻执行fsync）追加命令。如果这个key很大，就会造成主线程阻塞。

  另外两种，EverySec是先将命令写入内核缓冲区，每个1s将缓冲区内容写回硬盘，是创建一个异步任务执行fsync；No永远不会执行fsync。



对AOF重写与RDB快照的影响：

  AOF重写与生成RDB快照都会通过fork（）创建一个子进程执行任务。在创建子进程的过程中，os会把操作系统的页表复制给子进程。如果页表很大，这个过程会很耗时，因此执行fork()时就会有阻塞的现象。

  在AOF重写过程中，主进程修改key-value时会发生写时复制，会把物理内存复制一份。由于大key占用物理内存大，这一过程也是比较耗时的。于是父进程就会阻塞



定时检查大key，删除大key使用unlink，该命令是异步的

## 过期删除于内存淘汰策略

### 过期删除

redis在给一个键设置过期时间时，会向**过期字典**中加入键与过期时间。

有以下三种删除策略：

1. 定时删除
   在设置key的过期时间时同时创建一个定时事件，执行key的删除操作
   优点：保证key尽快被删除，对内存最友好
   确定：在key比较多的情况下，占用cpu过多的资源

2. 惰性删除
   每次访问一个key时，都会先检查是否过期，过期就删除

   `lazyfree_lazy_expire true `   

   优点：每次访问时才会检查是否过期，对cpu友好
   缺点：可能某一个key很久都不会被访问，那么就会一直存在于内存中，造成内存空间浪费

3. 定期删除
   每隔一段时间，会从redis中随机拿出一定数量的key进行检查，删除其中过期的key。若过期的数量达到一定比例则会继续新的一轮。

   `hz 10` 每10s执行一次

   优点：可以通过限制操作上限时间和频率，减少对cpu的影响
   缺点：难以确定操作执行时长和频率。太频繁，像定时删除；太少，像惰性删除

### 内存淘汰

当redis中存储的数据量达到上限时，就会根据内存淘汰策略删除一些key。有下面这些淘汰策略：

![image-20241118214226046](C:\Users\Administrator\AppData\Roaming\Typora\typora-user-images\image-20241118214226046.png)

## 缓存

### 雪崩

原因：大量缓存几乎同时失效，导致大量请求访问数据库，把数据库整垮

解决措施：

1. 分散缓存过期时间，给缓存过期时间加上一个随机数
2. 让缓存不失效，由后端主动更新缓存
3. 使用互斥锁，如果发现缓存不在redis里，加个互斥锁，保证同一时间只有一个请求构建缓存（从数据读，再更新到redis）

### 击穿

原因：热点缓存失效，大量请求访问数据库，把数据库整垮。其实也可以看作雪崩的一种情况。

解决措施：

1. 互斥锁
2. 不给热点数据设置过期时间，后台同步更新

### 穿透

原因：缓存中没有，数据库中也没有，真是炸缸了，数据库整垮。

解决措施：

1. 避免非法请求
2. 缓存默认值或空值
3. 使用布隆过滤器判断数据是否存在于数据库中
   后台在向数据库添加数据时，会将该数据保存至布隆过滤器中。后续大量请求则只会访问redis和布隆过滤器而不会访问数据库
