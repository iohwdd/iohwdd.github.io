[{"categories":null,"content":"内存区域 jdk1.8之后JVM的内存结构： 线程共享：堆[字符串常量池] 线程私有：程序计数器、虚拟机栈、本地方法栈 本地内存：元空间[运行时常量池(各种字面量和符合引用的常量池表)]、直接内存 ","date":"2024-11-19","objectID":"/jvm/:1:0","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"程序计数器 指示线程下一条执行的命令。与线程绑定同生共死 作用： 实现代码流程控制（分支、循环等） 在线程切换恢复之后，能够定位到接下来要执行的代码位置 ","date":"2024-11-19","objectID":"/jvm/:1:1","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"虚拟机栈 方法调用会形成一个栈帧，加入到虚拟机栈中，完成调用后出栈。 栈帧：包含了局部变量表、操作数表、动态链接、方法返回链接 局部变量表：存放编译期可知的各种数据类型 操作数栈：存放方法调用时产生的中间结果或临时变量 动态链接：当一个方法需要调用另外一个方法时，需要将符合引用转化为内存地址的直接引用。这个过程就是动态链接 可能出现的异常： OOM：容量太大，申请不到 StackFlow：栈的深度太大（递归） ","date":"2024-11-19","objectID":"/jvm/:1:2","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"本地方法栈 调用os中的方法所用到的栈 ","date":"2024-11-19","objectID":"/jvm/:1:3","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"堆 在jdk1.8之后，堆划分为新生代、老年代、元空间（1.7之前是永久代，被此替换）。堆空间是存放几乎所有对象实例的地方，对于某些方法中对象引用没有被返回或者没有被外部使用的（jdk1.7之后开启的逃逸分析），就直接在栈上分配内存。 新生代对象在Eden中，在新生代进行一次垃圾回收后，还存活的对象晋升至s1或s0，并将年龄设置为1。当年龄达到15（可以自己设置-XX:MaxTenuringThreshold ，最大为15，因为对象头中只提供了4位标识年龄）时，晋升至老年代。 补充最大年龄相关知识： 当survivor区某个年龄的数量超过了50%（可以通过-XX:TargetSurvivorRatio=percent 设置）时，会将晋升年龄与这个年龄取一个最小值作为新的晋升年龄。 可能出现的异常： Java heap space：申请不到足够内存了 GC Overhead Limit Exceeded：垃圾回收后仍然没有足够的内存。也就是说大部分对象都无法被垃圾回收。 ","date":"2024-11-19","objectID":"/jvm/:1:4","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"方法区 方法区是一个抽象概念，可以理解为一个接口，元空间是方法区的实现 该空间，主要存放类的元信息，如类信息、字段信息、静态变量等。当调用方法时使用到的类没有被加载（也就是元空间没有），就会先进行类加载，然后存入到元空间中。也就是说，类加载是懒加载。 元空间使用的是本地内存，默认没有使用上限 可以通过-XX:MetaspaceSize=N 设置初始大小，-XX:MaxMetaspaceSize=N 设置最大大小 ","date":"2024-11-19","objectID":"/jvm/:1:5","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"类初始化和类加载 创建对象的过程 类加载检查（没有加载过就先加载类） 在堆中分配空间，有两种方式 指针碰撞 适用情况：堆内存规整，没有碎片 原理：用过的内存放一边，没用过的放在另外一边，中间有一个分界指针，只要想着没用过的内存方向将指针移动对象内存大小即可 GC收集器：Serial, ParNew 空闲列表 适用情况：堆内存不规整，有碎片 原理：虚拟机维护一个列表记录哪些内存可用。在分配时找一块足够大的内存块分配给对象实例 GC收集器：CMS 内存分配并发问题，基于下面两种保证线程安全： CAS+失败重试：CAS为乐观锁的一种实现，发生冲突就会重试 TLAB：为每一个线程在Eden区分配一块内存，在线程中的对象创建时，先在TLAB创建，该区域用完时再采用上述的CAS进行内存分配 初始化为0值 设置对象头（标注哪个类的示例，用了什么锁等等） 执行构造器 对象的生命周期 创建：在堆中实例化 使用：被引用执行相应操作 销毁：不再被引用时，被垃圾回收，释放内存空间 对象的内存布局 对象头、实例数据、对齐填充 对象头： 标记字段：存储哈希码、GC年龄、锁标志等 类型指针：指向类元数据的指针，虚拟机凭此确定是哪个类的实例 实例数据：存放对象真正的有效信息，各种字段的内容 对齐填充：仅仅起到一个内存对齐的作用。虚拟机要求对象的其实地址必须是8的整数倍 对象的访问定位 句柄 直接指针 句柄的好处是在类移到时，只需要改变句柄中的实例指针，而reference本身不需要改；直接指针好处就是速度快，节省一次指针定位的开销。 类加载器 自顶向下分：启动类加载器（加载java核心库） -\u003e 扩展类加载器 （加载扩展目录下的jar包和类库）-\u003e 应用程序类加载器 （我们平时写的java程序）-\u003e 用户自定义类加载器 双亲委派模型：当类加载器收到类加载请求时，不会立马自己开始加载，而是交给父类加载器加载，若父加载器反馈自己无法完成这个加载请求，子加载器才会尝试自己去加载。 保证了类的唯一性，避免重复加载java类型 类加载过程 加载 将二进制流转化成方法区运行时的数据结构，在内存中生成一个代表类的Class对象 链接 验证 验证class文件中字节流的信息是否符合当前虚拟机的要求 准备 给静态字段分配内存，并设置默认值 解析 将常量池中的符合引用替换为直接引用 初始化 执行类的构造方法（编译器自动生成的） ","date":"2024-11-19","objectID":"/jvm/:2:0","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"垃圾回收 ","date":"2024-11-19","objectID":"/jvm/:3:0","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"死亡对象判断方法 引用计数法 给对象添加一个引用计数器，当有一个地方引用它计数器+1，当引用失效计数器-1。通过判断是否为0判断是否不再被引用。 缺陷：循环依赖的类即使不被其它地方引用，也无法识别回收 可达性分析算法 以GC ROOTS的对象为起点，向下搜索引用链，不在引用链上的对象则是不可用的对象，需要被回收。 引用类型总结 强引用：不会被垃圾回收 软引用：可有可无的对象。如果内存足够不会被回收，不够了就会回收 弱引用：一旦发生垃圾回收，该引用类型的对象都会被回收 虚引用：主要用来跟踪垃圾回收活动，必须与引用队列联合使用 判断一个类是无用的类 满足下面三个条件 该类所有的实例都已经被垃圾回收 该类的加载器已经被回收 没有地方使用该类的Class，如进行反射 ","date":"2024-11-19","objectID":"/jvm/:3:1","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"垃圾回收算法 标记-清除 标记存活对象（可达对象），对未标记的对象进行清理。 缺点：产生内存碎片，效率低 标记-复制 将内存分为大小相同的两块，当其中一块用完时，将其中存活的对象集中分配到另一块，然后再整个清理该内存块。 缺点：内存缩小一半，如果存活对象量大，效率低 标记-整理 ​ 将标记的对象整理在一块连续集中的空间（集中在一端），清理边 界外的内存 ","date":"2024-11-19","objectID":"/jvm/:3:2","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"垃圾收集器 Serial 单线程执行垃圾回收，并且会STW（用户线程暂停） ParNew serial的多线程版本，提高了效率 Parallel Scavnenge 类似ParNew，就是关注点在提高吞吐量（高效率利用CPU，尽可能少占用用户代码执行时间） CMS 旨在尽可能减少停顿时间，是并发收集器（几乎与用户线程同时工作，没有STW），采用标记-清除算法。 初始标记：标记直接与root相连的对象 并发标记：跟在垃圾回收时，引用发生更新的地方 重新标记：重新标记用户程序继续运行而导致标记产生变动的那一部分对象的标记记录 并发清除：开启用户线程，同时GC线程开始清扫 缺点：对CPU敏感，产生碎片 G1 采用标记-整理算法，低停顿时间，高吞吐量。 可以让使用者明确在指定M毫秒的时间内，消耗在垃圾收集器上的时间不得超过N毫秒。 初始标记 并发标记 最终标记 筛选回收 该收集器会在后台维护一个优先列表，每次根据收集时间，选择回收价值最大的Region，效率高。 ","date":"2024-11-19","objectID":"/jvm/:3:3","tags":null,"title":"JVM","uri":"/jvm/"},{"categories":null,"content":"数据类型 String 底层实现：SDS，相比于c语言中的string有以下优点 可以保存除文本外的音视频图片信息。底层以二进制形式的数据保存至buf[]中，因此可以存音视频图片等二进制文件信息 查询字符串长度的时间复杂度为O(1)。因为底层记录了字符串的长度大小 高效拼接字符串，且之前会检查容量是否足够，避免缓冲区溢出 应用场景 存Json格式的对象信息 计数器 当key为整数时，提供了相关的api能对整数进行简单的增值降值操作。可以实现点赞/转发/访问数量等 分布式锁 set 命令有个参数 NX 可以实现key值不存在时成功插入，存在时插入失败。可对应key存在时，对应加锁失败，不存在时对应加锁成功。 对于解锁的过程，有两个步骤：判断锁的unique_value是否为加锁的客户端、删除lock_key锁。这时就需要lua脚本保证解锁的原子性。 共享session 当有多个服务器时，同一个用户可能每次访问不同的服务器，因而每次获取到的session不一致。可以通过在redis中统一存储sessionId，每个服务器都与redis建立连接，每个服务器都只会去同一个redis中获取session信息 List 底层实现：老版本是双向链表或压缩链表，redis 3.2 之后则统一由quicklist实现 应用场景： 消息队列 消息有序性：lpush+brpop实现（rpush+blpop也可）。使用brpop不使用rpop的原因是，brpop为阻塞式取数据，如果列表中没有数据时会阻塞等待直到有数据过来。如果用rpop，就需要消费者死循环不断去列表中获取，这很消耗cpu资源。 处理重复消息：给消息附加上一个全局唯一id标识，消费者消费之前判断是否消息过这条消息 可靠性：BRPOPLPUSH，消费者从list读取消息时，同时会将该消息写道另外一个list（备份list）。这样即使消费者在处理消息时宕机了，重启可以从备份list获取消息重新处理 ​ 不过上述方式实现的消息队列，每条消息只能被一个消费者消费 Hash 底层实现：老版本是压缩链表或哈希表，redis 7.0之后统一由listpack实现 应用场景： 购物车 用户id + 商品id:购买数量，刚好构成了购物车的三要素。 以用户id为key，商品id:购买数量键值对为value，存入hash中即可 Set 有序的、元素不可重复的集合 底层实现：整数集合或哈希表 应用场景： 点赞 与点赞相关的业务：数量、只能点赞一次、获取点赞的用户 共同关注 交集。另外利用差集，可以给对方推荐自己关注的公众号 抽奖活动 使用srandmember实现可重复中奖 使用spop实现不可重复中奖 ZSet 有序的、元素不可重复的集合 底层实现：老版本压缩列表或跳表实现，redis 7.0之后由listpack实现 应用场景： 排行榜 电话、姓名排序 ZRANGEBYLEX和 ZREVRANGEBYLEX实现，分数必须相同，设置为0即可。 Geo 底层实现：就是Zsort，只是将经纬度信息进行编码实现了到权重分数的转换 应用场景： 滴滴叫车 搜索附件车辆 BitMap 底层实现：底层是用string类型实现的数据结构，string类型会将数据最终保存为二进制字节数组buf[],所以可以把每个bit位利用起来就可以当成一个bitmap 应用场景 用户签到：月签到天数（一个用户一个bitmap）、七天连续签到（一天一个bitmap，多个bitmap进行\u0026操作） 判断用户登录状态 ","date":"2024-11-19","objectID":"/redis/:1:0","tags":null,"title":"Redis","uri":"/redis/"},{"categories":null,"content":"持久化 ","date":"2024-11-19","objectID":"/redis/:2:0","tags":null,"title":"Redis","uri":"/redis/"},{"categories":null,"content":"AOF日志 通过在客户端在redis中执行写命令之后，会将写命令追加到AOF日志文件，这样一来AOF日志文件保存了所有的写命令。系统异常造成数据丢失时，可通过执行AOF日志中的命令完成数据恢复。 Q：为什么要在执行写命令之后再写入AOF？ A：执行命令时会检查语法问题，避免写入时还要检查语法是否正确 三种写回策略 每执行一条写命令不会立即写入磁盘中的AOF文件，而是先写入缓冲区。后续由操作系统将缓冲区的内容追加到AOF文件。具体写回的策略有以下三种 Always：每执行一个命令，os就将该命令追加到AOF EverySec： 每隔1s，将缓冲区的内容追加到AOF No： 完全交由os决定什么时候写入AOF 可靠性：Always 高性能：No 运行数据丢一点，又想性能高：No AOF重写机制 当AOF文件很大达到一定阈值时，会触发重写机制。重写机制就是读取当前redis数据库中所有的键值对，每个键值对形成一条写命令，写入新的AOF文件中，最后更名替换旧的AOF文件。 AOF后台重写 为避免AOF重写在主线程运行造成阻塞，采用子进程完成AOF的重写。 Q：为什么不是子线程而是子进程？ A：多线程之间会共享数据，在修改共享内存数据时需要通过加锁保证数据的安全，这样就会降低性能。而使用子进程，父子进程是共享内存数据的，不过这个子进程只能以只读的方式。当父子进程任意一方修改了共享内存，就会发送写时复制，于是父子进程都有了独立的数据副本，就不用加锁来保证数据安全。 如果在子进程进行AOF重写的同时，主进程又修改了key-value，那么会导致两个问题，一个是子进程的数据跟主进程数据不一致；另一个是若是个bigkey，会造成主进程阻塞。为了解决这个问题，redis在重写期间，在执行一条写命令之后，会将其写入到AOF缓冲区和AOF重写缓冲区 子进程完成重写操作后，会向父进程发送信号，父进程接收到信号后，会执行信号处理函数，这个函数执行将AOF重写缓冲区的内容追加到新的AOF文件中，新的AOF文件更名覆盖旧的AOF文件，完成AOF后台重写。 AOF做持久化的缺点 因为redis执行命令由单线程执行，如果AOF文件很大，这个恢复的过程就会很慢 ","date":"2024-11-19","objectID":"/redis/:2:1","tags":null,"title":"Redis","uri":"/redis/"},{"categories":null,"content":"RDB快照 以二进制文件的形式存储redis数据库某一时刻的数据快照。使用save和bgsave两个命令生成RDB文件，其中后者是创建子进程执行。每次在服务器启动时自动执行，也可以修改配置文件修改执行频次。该方式执行效率高于AOF日志。 如果生成RDB快照时，数据被修改的话是无法更新至RDB快照中的，但是可以通过缓冲区追加到AOF日志文件中。 RDB执行频率低会导致数据丢失多，频率高导致写入磁盘和创建子进程带来额外的开销。开启混合持久化功能（发送在AOF日志重写过程），aof-use-rdb-preamble yes ，在重写日志时，会以RBD方式写入到AOF文件中，再将重写缓冲区的增量命令追加到AOF文件中。写入完成后，会通知主线程新的还要RDB和AOF格式的AOF文件替换旧的AOF文件。 如此前半部分是RDB格式的全量数据，后半部分是AOF格式的增量数据，使得数据更少丢失。 ","date":"2024-11-19","objectID":"/redis/:2:2","tags":null,"title":"Redis","uri":"/redis/"},{"categories":null,"content":"大key对持久化的影响 对于AOF日志持久化： 只会影响Alawyas写回策略，因为每执行一个写命令就向AOF日志（立刻执行fsync）追加命令。如果这个key很大，就会造成主线程阻塞。 另外两种，EverySec是先将命令写入内核缓冲区，每个1s将缓冲区内容写回硬盘，是创建一个异步任务执行fsync；No永远不会执行fsync。 对AOF重写与RDB快照的影响： AOF重写与生成RDB快照都会通过fork（）创建一个子进程执行任务。在创建子进程的过程中，os会把操作系统的页表复制给子进程。如果页表很大，这个过程会很耗时，因此执行fork()时就会有阻塞的现象。 在AOF重写过程中，主进程修改key-value时会发生写时复制，会把物理内存复制一份。由于大key占用物理内存大，这一过程也是比较耗时的。于是父进程就会阻塞 定时检查大key，删除大key使用unlink，该命令是异步的 ","date":"2024-11-19","objectID":"/redis/:2:3","tags":null,"title":"Redis","uri":"/redis/"},{"categories":null,"content":"过期删除于内存淘汰策略 ","date":"2024-11-19","objectID":"/redis/:3:0","tags":null,"title":"Redis","uri":"/redis/"},{"categories":null,"content":"过期删除 redis在给一个键设置过期时间时，会向过期字典中加入键与过期时间。 有以下三种删除策略： 定时删除 在设置key的过期时间时同时创建一个定时事件，执行key的删除操作 优点：保证key尽快被删除，对内存最友好 确定：在key比较多的情况下，占用cpu过多的资源 惰性删除 每次访问一个key时，都会先检查是否过期，过期就删除 lazyfree_lazy_expire true 优点：每次访问时才会检查是否过期，对cpu友好 缺点：可能某一个key很久都不会被访问，那么就会一直存在于内存中，造成内存空间浪费 定期删除 每隔一段时间，会从redis中随机拿出一定数量的key进行检查，删除其中过期的key。若过期的数量达到一定比例则会继续新的一轮。 hz 10 每10s执行一次 优点：可以通过限制操作上限时间和频率，减少对cpu的影响 缺点：难以确定操作执行时长和频率。太频繁，像定时删除；太少，像惰性删除 ","date":"2024-11-19","objectID":"/redis/:3:1","tags":null,"title":"Redis","uri":"/redis/"},{"categories":null,"content":"内存淘汰 当redis中存储的数据量达到上限时，就会根据内存淘汰策略删除一些key。有下面这些淘汰策略： ","date":"2024-11-19","objectID":"/redis/:3:2","tags":null,"title":"Redis","uri":"/redis/"},{"categories":null,"content":"缓存 ","date":"2024-11-19","objectID":"/redis/:4:0","tags":null,"title":"Redis","uri":"/redis/"},{"categories":null,"content":"雪崩 原因：大量缓存几乎同时失效，导致大量请求访问数据库，把数据库整垮 解决措施： 分散缓存过期时间，给缓存过期时间加上一个随机数 让缓存不失效，由后端主动更新缓存 使用互斥锁，如果发现缓存不在redis里，加个互斥锁，保证同一时间只有一个请求构建缓存（从数据读，再更新到redis） ","date":"2024-11-19","objectID":"/redis/:4:1","tags":null,"title":"Redis","uri":"/redis/"},{"categories":null,"content":"击穿 原因：热点缓存失效，大量请求访问数据库，把数据库整垮。其实也可以看作雪崩的一种情况。 解决措施： 互斥锁 不给热点数据设置过期时间，后台同步更新 ","date":"2024-11-19","objectID":"/redis/:4:2","tags":null,"title":"Redis","uri":"/redis/"},{"categories":null,"content":"穿透 原因：缓存中没有，数据库中也没有，真是炸缸了，数据库整垮。 解决措施： 避免非法请求 缓存默认值或空值 使用布隆过滤器判断数据是否存在于数据库中 后台在向数据库添加数据时，会将该数据保存至布隆过滤器中。后续大量请求则只会访问redis和布隆过滤器而不会访问数据库 ","date":"2024-11-19","objectID":"/redis/:4:3","tags":null,"title":"Redis","uri":"/redis/"}]