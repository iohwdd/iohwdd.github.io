# JVM




## 内存区域

jdk1.8之后JVM的内存结构：

线程共享：堆[字符串常量池]

线程私有：程序计数器、虚拟机栈、本地方法栈

本地内存：元空间[运行时常量池(各种字面量和符合引用的常量池表)]、直接内存

### 程序计数器

指示线程下一条执行的命令。与线程绑定同生共死

作用：

1. 实现代码流程控制（分支、循环等）
2. 在线程切换恢复之后，能够定位到接下来要执行的代码位置



### 虚拟机栈

方法调用会形成一个栈帧，加入到虚拟机栈中，完成调用后出栈。

栈帧：包含了局部变量表、操作数表、动态链接、方法返回链接

局部变量表：存放编译期可知的各种**数据类型**

操作数栈：存放方法调用时产生的中间结果或临时变量

动态链接：当一个方法需要调用另外一个方法时，需要将符号引用转化为内存地址的直接引用。这个过程就是动态链接



可能出现的异常：

OOM：容量太大，申请不到

StackFlow：栈的深度太大（递归）



### 本地方法栈

调用os中的方法所用到的栈



### 堆

在jdk1.8之后，堆划分为新生代、老年代、元空间（1.7之前是永久代，被此替换）。堆空间是存放**几乎**所有对象实例的地方，对于某些方法中对象引用没有被返回或者没有被外部使用的（jdk1.7之后开启的逃逸分析），就直接在栈上分配内存。

![image-20241119153904527](https://www.helloimg.com/i/2024/11/20/673dbbb11b3fc.png)

新生代对象在Eden中，在新生代进行一次垃圾回收后，还存活的对象晋升至s1或s0，并将年龄设置为1。当年龄达到15（可以自己设置`-XX:MaxTenuringThreshold` ，最大为15，因为对象头中只提供了4位标识年龄）时，晋升至老年代。

补充最大年龄相关知识：

当survivor区某个年龄的数量超过了50%（可以通过`-XX:TargetSurvivorRatio=percent` 设置）时，会将晋升年龄与这个年龄取一个最小值作为新的晋升年龄。

可能出现的异常：

**`Java heap space`**：申请不到足够内存了

**`GC Overhead Limit Exceeded`**：垃圾回收后仍然没有足够的内存。也就是说大部分对象都无法被垃圾回收。



### 方法区

方法区是一个抽象概念，可以理解为一个接口，元空间是方法区的实现

该空间，主要存放类的元信息，如类信息、字段信息、静态变量等。当调用方法时使用到的类没有被加载（也就是元空间没有），就会先进行类加载，然后存入到元空间中。也就是说，类加载是懒加载。



元空间使用的是本地内存，默认没有使用上限

可以通过`-XX:MetaspaceSize=N` 设置初始大小，`-XX:MaxMetaspaceSize=N` 设置最大大小



Q：基础类型在 jvm 中的存储
A： 1.存在虚拟机栈中方法栈帧的局部变量表中
	   2.存在堆里的实例对象的成语变量里
	   3.存在元空间（类静态变量）
	   4.运行时常量池（由 final 修饰）

## 类初始化和类加载

**类加载过程**

1. 加载
   将二进制流转化成方法区【元空间】运行时的数据结构，在内存中生成一个代表类的Class对象
2. 链接
   1. 验证
      验证class文件中字节流的信息是否符合当前虚拟机的要求
   2. 准备
      给静态字段分配内存，并设置默认值
   3. 解析
      将常量池中的符合引用替换为直接引用
3. 初始化
   执行类的初始化方法（编译器自动生成的）



**创建对象的过程**

1. 类加载检查（没有加载过就先加载类）

2. 在堆中分配空间，有两种方式

   1. 指针碰撞
      适用情况：堆内存规整，没有碎片
      原理：用过的内存放一边，没用过的放在另外一边，中间有一个分界指针，只要向着没用过的内存方向将指针移动对象内存大小即可
      GC收集器：Serial, ParNew
   2. 空闲列表
      适用情况：堆内存不规整，有碎片
      原理：虚拟机维护一个列表记录哪些内存可用。在分配时找一块足够大的内存块分配给对象实例
      GC收集器：CMS

   内存分配并发问题，基于下面两种保证线程安全：

   - CAS+失败重试：CAS为乐观锁的一种实现，发生冲突就会重试
   - TLAB：为**每一个线程**在Eden区分配一块内存，在线程中的对象创建时，先在TLAB创建，该区域用完时再采用上述的CAS进行内存分配

3. 初始化为0值

4. 设置对象头（标注哪个类的示例，用了什么锁等等）
   类型指针、对象运行时数据，如hashcode、分代年龄、锁状态等信息

5. 执行构造器



**对象的生命周期**

1. 创建：在堆中实例化
2. 使用：被引用执行相应操作
3. 销毁：不再被引用时，被垃圾回收，释放内存空间



**对象的内存布局**

对象头、实例数据、对齐填充

对象头：

1. 标记字段：存储哈希码、GC年龄、锁标志等
2. 类型指针：指向类元数据的指针，虚拟机凭此确定是哪个类的实例

实例数据：存放对象真正的有效信息，各种字段的内容

对齐填充：仅仅起到一个内存对齐的作用。虚拟机要求对象的其实地址必须是8的整数倍



**对象的访问定位**

句柄

![image-20241119162527018](https://www.helloimg.com/i/2024/11/20/673dbbe75e63c.png)

直接指针

![image-20241119162603057](https://www.helloimg.com/i/2024/11/20/673dbc054ca1d.png)

句柄的好处是在类移到时，只需要改变句柄中的实例指针，而reference本身不需要改；直接指针好处就是速度快，节省一次指针定位的开销。



类加载器

自顶向下分：**启动类加载器**（加载java核心库） -> **扩展类加载器** （加载扩展目录下的jar包和类库）->  **应用程序类加载器** （我们平时写的java程序）-> **用户自定义类加载器**

双亲委派模型：当类加载器收到类加载请求时，不会立马自己开始加载，而是交给父类加载器加载，若父加载器反馈自己无法完成这个加载请求，子加载器才会尝试自己去加载。

保证了类的唯一性，避免重复加载java类型





## 垃圾回收



### 死亡对象判断方法

**引用计数法**

给对象添加一个引用计数器，当有一个地方引用它计数器+1，当引用失效计数器-1。通过判断是否为0判断是否不再被引用。

缺陷：循环依赖的类即使不被其它地方引用，也无法识别回收



**可达性分析算法**

以GC ROOTS的对象为起点，向下搜索引用链，不在引用链上的对象则是不可用的对象，需要被回收。



**引用类型总结**

强引用：不会被垃圾回收

软引用：可有可无的对象。如果内存足够不会被回收，不够了就会回收

弱引用：一旦发生垃圾回收，该引用类型的对象都会被回收

虚引用：主要用来跟踪垃圾回收活动，必须与引用队列联合使用



**判断一个类是无用的类**

满足下面三个条件

1. 该类所有的实例都已经被垃圾回收
2. 该类的加载器已经被回收
3. 没有地方使用该类的Class，如进行反射



### 垃圾回收算法

1. 标记-清除
   标记存活对象（可达对象），对未标记的对象进行清理。

   缺点：产生内存碎片，效率低

2. 标记-复制
   将内存分为大小相同的两块，当其中一块用完时，将其中存活的对象集中分配到另一块，然后再整个清理该内存块。
   缺点：内存缩小一半，如果存活对象量大，效率低

3. 标记-整理

​		将标记的对象整理在一块连续集中的空间（集中在一端），然后清理边界外的内存



### 垃圾收集器

Serial

单线程执行垃圾回收，并且会STW（用户线程暂停）



ParNew

serial的多线程版本，提高了效率



Parallel Scavnenge

类似ParNew，就是关注点在提高吞吐量（高效率利用CPU，尽可能少占用用户代码执行时间）



**CMS**

主要用于**老年代**的回收。旨在尽可能减少停顿时间，是并发收集器（几乎与用户线程同时工作，没有STW），采用标记-清除算法。

初始标记：标记直接与 gc roots 相连的对象。会造成 stw 但时间很短。

并发标记：gc 线程 与用户线程并发执行，标记所有可达对象。

重新标记：处理在并发标记阶段新增的对象或更新的引用关系。也会 stw 同样时间很短。

并发清除：与用户线程并发执行，清除未被标记的对象。

优点：并发标记和并发清除几乎不会停止应用程序，停顿时间短
缺点：造成内存碎片，可能导致老年代无法分配大对象。与用户线程争夺 cpu 资源。



**G1**

采用标记-整理算法，低停顿时间，高吞吐量，**回收时间可控**。

去掉了新生代老年代的概念，在逻辑上将堆区域划分成 2048 个 region（具体大小根据堆空间而定），可以控制垃圾回收时间，并在规定时间内优先回收优先级最高的 region，避免对整个新生代或老年代进行回收。

可以让使用者明确在指定M毫秒的时间内，消耗在垃圾收集器上的时间不得超过N毫秒。

- 初始标记
- 并发标记
- 最终标记
- 筛选回收

该收集器会在后台维护一个优先列表，每次根据收集时间，选择回收价值最大的Region，效率高。



**三色标记法**

将所有对象分成黑灰白三种。白色未被访问，灰色被访问了但是内部的引用对象还未访问，黑色除了本身其内部所有的引用对象都被访问。
初始化：遍历所有 gc roots 标记为灰色，放入工作列表中
标记过程：不断从工作列表取出灰色对象，将其标记成黑色，并将其中的引用对象标记成灰色。递归执行，直到工作列表会空。
清除阶段：清理所有白色对象，都是不可达的
优点：
天然支持增量回收。
由于标记阶段分阶段进行减少 stw 时间。
避免重复扫描。
采用颜色标记的方式能够有效避免扫码同一对象。
存在的问题：在并发回收过程中如果白色对象引用赋值给黑色对象，可能导致垃圾回收器认为该白色对象为不可达对象。
解决办法：
写屏障，确保所有新引用的对象都标记为灰色。
读屏障，确保读取都对象不会被错误回收

